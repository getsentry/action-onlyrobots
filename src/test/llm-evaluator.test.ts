import { describe, it, expect, beforeAll } from 'vitest';
import { LLMEvaluator } from '../llm-evaluator';

describe('LLMEvaluator', () => {
  let evaluator: LLMEvaluator;

  beforeAll(() => {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY must be set in .env file for tests');
    }
    evaluator = new LLMEvaluator({ OPENAI_API_KEY: apiKey });
  });

  describe('evaluateFile', () => {
    it('should detect obvious AI-generated code patterns', async () => {
      const aiCode = `
// Generated by Claude Code
export interface UserConfigurationParameters {
  userDisplayName: string;
  userEmailAddress: string;
  userPreferencesSettings: string;
}

/**
 * Validates the user configuration parameters to ensure all required fields are present and valid
 * @param configurationParameters The user configuration parameters object to validate
 * @returns Returns true if the configuration is valid, false otherwise
 */
export function validateUserConfigurationParameters(configurationParameters: UserConfigurationParameters): boolean {
  try {
    if (!configurationParameters) {
      throw new Error('Configuration parameters cannot be null or undefined');
    }
    
    if (!configurationParameters.userDisplayName || configurationParameters.userDisplayName.length === 0) {
      throw new Error('User display name is required and cannot be empty');
    }
    
    if (!configurationParameters.userEmailAddress || !configurationParameters.userEmailAddress.includes('@')) {
      throw new Error('Valid email address is required');
    }
    
    return true;
  } catch (error) {
    console.error('Configuration validation failed:', error);
    return false;
  }
}
`;

      const result = await evaluator.evaluateFile('user-config.ts', aiCode);

      expect(result).toBeDefined();
      expect(result.confidence).toBeGreaterThan(0);
      expect(result.confidence).toBeLessThanOrEqual(100);
      expect(result.reasoning).toBeDefined();
      expect(Array.isArray(result.indicators)).toBe(true);
      expect(typeof result.isHumanLike).toBe('boolean');

      // This has obvious AI indicators - should be detected
      expect(result.isHumanLike).toBe(false);
    });

    it('should detect human-written code patterns', async () => {
      const humanCode = `
var data = null; // TODO: fix this later
console.log("debug here");
function test() {
  debugger;
  return foo;
}
`;

      const result = await evaluator.evaluateFile('messy-code.js', humanCode);

      expect(result).toBeDefined();
      expect(result.confidence).toBeGreaterThan(0);
      expect(result.confidence).toBeLessThanOrEqual(100);
      expect(result.reasoning).toBeDefined();
      expect(Array.isArray(result.indicators)).toBe(true);
      expect(typeof result.isHumanLike).toBe('boolean');

      // Human-written code should typically score as human-like
      expect(result.isHumanLike).toBe(true);
    });

    it('should detect AI tool attribution', async () => {
      const codeWithAttribution = `
// This code was generated by Claude Code
export function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
`;

      const result = await evaluator.evaluateFile('calculator.ts', codeWithAttribution);

      expect(result).toBeDefined();
      expect(result.isHumanLike).toBe(false);
      expect(
        result.indicators.some(
          (i) => i.toLowerCase().includes('ai') || i.toLowerCase().includes('tool')
        )
      ).toBe(true);
      expect(result.reasoning.toLowerCase()).toContain('claude');
    });

    it('should handle empty code gracefully', async () => {
      const result = await evaluator.evaluateFile('empty.ts', '');

      expect(result).toBeDefined();
      expect(result.confidence).toBeGreaterThan(0);
      expect(result.reasoning).toBeDefined();
    });
  });

  describe('evaluatePullRequest', () => {
    it('should aggregate results from multiple files', async () => {
      const files = [
        {
          filename: 'ai-code.ts',
          patch: `
// Auto-generated using GitHub Copilot
export interface ApplicationConfigurationInterface {
  applicationProgrammingInterfaceKey: string;
  databaseConnectionStringParameter: string;
}

/**
 * Validates the application configuration interface to ensure all required parameters are present
 * @param configurationInterface The configuration interface object to validate
 * @returns Boolean indicating whether the configuration is valid
 */
export function validateApplicationConfigurationInterface(configurationInterface: ApplicationConfigurationInterface): boolean {
  try {
    if (!configurationInterface.applicationProgrammingInterfaceKey || configurationInterface.applicationProgrammingInterfaceKey.length === 0) {
      throw new Error('Application Programming Interface Key is required');
    }
    return true;
  } catch (error) {
    console.error('Configuration validation error:', error);
    return false;
  }
}
`,
        },
        {
          filename: 'human-code.js',
          patch: `
var x = 1; // TODO: cleanup
console.log("test");
function foo() {
  debugger;
  return x;
}
`,
        },
      ];

      const result = await evaluator.evaluatePullRequest(files);

      expect(result).toBeDefined();
      expect(result.overallResult).toBeDefined();
      expect(result.fileResults).toHaveLength(2);

      expect(result.overallResult.confidence).toBeGreaterThan(0);
      expect(result.overallResult.confidence).toBeLessThanOrEqual(100);
      expect(result.overallResult.reasoning).toBeDefined();
      expect(Array.isArray(result.overallResult.indicators)).toBe(true);

      // Should flag as human-like due to the human-code.js file
      expect(result.overallResult.isHumanLike).toBe(true);

      // Check individual file results
      const aiFile = result.fileResults.find((f) => f.filename === 'ai-code.ts');
      const humanFile = result.fileResults.find((f) => f.filename === 'human-code.js');

      expect(aiFile?.result.isHumanLike).toBe(false);
      expect(humanFile?.result.isHumanLike).toBe(true);
    });

    it('should handle all AI-generated files', async () => {
      const files = [
        {
          filename: 'types.ts',
          patch: `
// Generated by Cursor AI
export interface UserAccountInformationInterface {
  userIdentificationNumber: string;
  userDisplayNameString: string;
  userEmailAddressString: string;
  userAccountCreationTimestamp: Date;
}

export type UserAccountRoleTypeDefinition = 'administratorRole' | 'standardUserRole' | 'guestUserRole';
`,
        },
        {
          filename: 'utils.ts',
          patch: `
/**
 * Formats the user display name by concatenating user information parameters
 * @param userAccountInformation The user account information interface object
 * @returns Formatted user display name string with email address
 */
export function formatUserDisplayNameWithEmailAddress(userAccountInformation: UserAccountInformationInterface): string {
  try {
    if (!userAccountInformation || !userAccountInformation.userDisplayNameString || !userAccountInformation.userEmailAddressString) {
      throw new Error('Valid user account information is required for formatting');
    }
    return \`\${userAccountInformation.userDisplayNameString} <\${userAccountInformation.userEmailAddressString}>\`;
  } catch (error) {
    console.error('User display name formatting error:', error);
    return '';
  }
}
`,
        },
      ];

      const result = await evaluator.evaluatePullRequest(files);

      expect(result).toBeDefined();
      expect(result.overallResult.isHumanLike).toBe(false);
      expect(result.fileResults).toHaveLength(2);

      // All files should be flagged as AI-generated
      for (const fileResult of result.fileResults) {
        expect(fileResult.result.isHumanLike).toBe(false);
      }
    });

    it('should handle empty file list', async () => {
      const result = await evaluator.evaluatePullRequest([]);

      expect(result).toBeDefined();
      expect(result.overallResult).toBeDefined();
      expect(result.fileResults).toHaveLength(0);
    });
  });
});
