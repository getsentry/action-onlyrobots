"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const llm_evaluator_1 = require("../llm-evaluator");
(0, vitest_1.describe)('LLMEvaluator', () => {
    let evaluator;
    (0, vitest_1.beforeAll)(() => {
        const apiKey = process.env.OPENAI_API_KEY;
        if (!apiKey) {
            throw new Error('OPENAI_API_KEY must be set in .env file for tests');
        }
        evaluator = new llm_evaluator_1.LLMEvaluator({ OPENAI_API_KEY: apiKey });
    });
    (0, vitest_1.describe)('evaluateFile', () => {
        (0, vitest_1.it)('should detect AI-generated code patterns', async () => {
            const aiCode = `
export interface UserConfig {
  name: string;
  email: string;
}

/**
 * Validates user configuration
 * @param config The user configuration to validate
 * @returns True if valid, false otherwise
 */
export function validateUserConfig(config: UserConfig): boolean {
  return config.name.length > 0 && config.email.includes('@');
}
`;
            const result = await evaluator.evaluateFile('user-config.ts', aiCode);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.confidence).toBeGreaterThan(0);
            (0, vitest_1.expect)(result.confidence).toBeLessThanOrEqual(100);
            (0, vitest_1.expect)(result.reasoning).toBeDefined();
            (0, vitest_1.expect)(Array.isArray(result.indicators)).toBe(true);
            (0, vitest_1.expect)(typeof result.isHumanLike).toBe('boolean');
            // AI-generated code should typically score as not human-like
            (0, vitest_1.expect)(result.isHumanLike).toBe(false);
        });
        (0, vitest_1.it)('should detect human-written code patterns', async () => {
            const humanCode = `
var data = null; // TODO: fix this later
console.log("debug here");
function test() {
  debugger;
  return foo;
}
`;
            const result = await evaluator.evaluateFile('messy-code.js', humanCode);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.confidence).toBeGreaterThan(0);
            (0, vitest_1.expect)(result.confidence).toBeLessThanOrEqual(100);
            (0, vitest_1.expect)(result.reasoning).toBeDefined();
            (0, vitest_1.expect)(Array.isArray(result.indicators)).toBe(true);
            (0, vitest_1.expect)(typeof result.isHumanLike).toBe('boolean');
            // Human-written code should typically score as human-like
            (0, vitest_1.expect)(result.isHumanLike).toBe(true);
        });
        (0, vitest_1.it)('should detect AI tool attribution', async () => {
            const codeWithAttribution = `
// This code was generated by Claude Code
export function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
`;
            const result = await evaluator.evaluateFile('calculator.ts', codeWithAttribution);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.isHumanLike).toBe(false);
            (0, vitest_1.expect)(result.indicators.some((i) => i.toLowerCase().includes('ai') || i.toLowerCase().includes('tool'))).toBe(true);
            (0, vitest_1.expect)(result.reasoning.toLowerCase()).toContain('claude');
        });
        (0, vitest_1.it)('should handle empty code gracefully', async () => {
            const result = await evaluator.evaluateFile('empty.ts', '');
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.confidence).toBeGreaterThan(0);
            (0, vitest_1.expect)(result.reasoning).toBeDefined();
        });
    });
    (0, vitest_1.describe)('evaluatePullRequest', () => {
        (0, vitest_1.it)('should aggregate results from multiple files', async () => {
            const files = [
                {
                    filename: 'ai-code.ts',
                    patch: `
export interface Config {
  apiKey: string;
}

export function validateConfig(config: Config): boolean {
  return config.apiKey.length > 0;
}
`,
                },
                {
                    filename: 'human-code.js',
                    patch: `
var x = 1; // TODO: cleanup
console.log("test");
function foo() {
  debugger;
  return x;
}
`,
                },
            ];
            const result = await evaluator.evaluatePullRequest(files);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.overallResult).toBeDefined();
            (0, vitest_1.expect)(result.fileResults).toHaveLength(2);
            (0, vitest_1.expect)(result.overallResult.confidence).toBeGreaterThan(0);
            (0, vitest_1.expect)(result.overallResult.confidence).toBeLessThanOrEqual(100);
            (0, vitest_1.expect)(result.overallResult.reasoning).toBeDefined();
            (0, vitest_1.expect)(Array.isArray(result.overallResult.indicators)).toBe(true);
            // Should flag as human-like due to the human-code.js file
            (0, vitest_1.expect)(result.overallResult.isHumanLike).toBe(true);
            // Check individual file results
            const aiFile = result.fileResults.find((f) => f.filename === 'ai-code.ts');
            const humanFile = result.fileResults.find((f) => f.filename === 'human-code.js');
            (0, vitest_1.expect)(aiFile?.result.isHumanLike).toBe(false);
            (0, vitest_1.expect)(humanFile?.result.isHumanLike).toBe(true);
        });
        (0, vitest_1.it)('should handle all AI-generated files', async () => {
            const files = [
                {
                    filename: 'types.ts',
                    patch: `
export interface User {
  id: string;
  name: string;
  email: string;
}

export type UserRole = 'admin' | 'user' | 'guest';
`,
                },
                {
                    filename: 'utils.ts',
                    patch: `
/**
 * Formats a user's display name
 * @param user The user object
 * @returns Formatted display name
 */
export function formatUserName(user: User): string {
  return \`\${user.name} <\${user.email}>\`;
}
`,
                },
            ];
            const result = await evaluator.evaluatePullRequest(files);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.overallResult.isHumanLike).toBe(false);
            (0, vitest_1.expect)(result.fileResults).toHaveLength(2);
            // All files should be flagged as AI-generated
            for (const fileResult of result.fileResults) {
                (0, vitest_1.expect)(fileResult.result.isHumanLike).toBe(false);
            }
        });
        (0, vitest_1.it)('should handle empty file list', async () => {
            const result = await evaluator.evaluatePullRequest([]);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.overallResult).toBeDefined();
            (0, vitest_1.expect)(result.fileResults).toHaveLength(0);
        });
    });
});
//# sourceMappingURL=llm-evaluator.test.js.map