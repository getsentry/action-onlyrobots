"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const llm_evaluator_1 = require("../llm-evaluator");
(0, vitest_1.describe)('LLMEvaluator', () => {
    let evaluator;
    (0, vitest_1.beforeAll)(() => {
        const apiKey = process.env.OPENAI_API_KEY;
        if (!apiKey) {
            throw new Error('OPENAI_API_KEY must be set in .env file for tests');
        }
        evaluator = new llm_evaluator_1.LLMEvaluator({ OPENAI_API_KEY: apiKey });
    });
    (0, vitest_1.describe)('evaluateFile', () => {
        (0, vitest_1.it)('should detect obvious AI-generated code patterns', async () => {
            const aiCode = `
// Generated by Claude Code
export interface UserConfigurationParameters {
  userDisplayName: string;
  userEmailAddress: string;
  userPreferencesSettings: string;
}

/**
 * Validates the user configuration parameters to ensure all required fields are present and valid
 * @param configurationParameters The user configuration parameters object to validate
 * @returns Returns true if the configuration is valid, false otherwise
 */
export function validateUserConfigurationParameters(configurationParameters: UserConfigurationParameters): boolean {
  try {
    if (!configurationParameters) {
      throw new Error('Configuration parameters cannot be null or undefined');
    }
    
    if (!configurationParameters.userDisplayName || configurationParameters.userDisplayName.length === 0) {
      throw new Error('User display name is required and cannot be empty');
    }
    
    if (!configurationParameters.userEmailAddress || !configurationParameters.userEmailAddress.includes('@')) {
      throw new Error('Valid email address is required');
    }
    
    return true;
  } catch (error) {
    console.error('Configuration validation failed:', error);
    return false;
  }
}
`;
            const result = await evaluator.evaluateFile('user-config.ts', aiCode);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.confidence).toBeGreaterThan(0);
            (0, vitest_1.expect)(result.confidence).toBeLessThanOrEqual(100);
            (0, vitest_1.expect)(result.reasoning).toBeDefined();
            (0, vitest_1.expect)(Array.isArray(result.indicators)).toBe(true);
            (0, vitest_1.expect)(typeof result.isHumanLike).toBe('boolean');
            // This has obvious AI indicators - should be detected
            (0, vitest_1.expect)(result.isHumanLike).toBe(false);
        });
        (0, vitest_1.it)('should detect human-written code patterns', async () => {
            const humanCode = `
var data = null; // TODO: fix this later
console.log("debug here");
function test() {
  debugger;
  return foo;
}
`;
            const result = await evaluator.evaluateFile('messy-code.js', humanCode);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.confidence).toBeGreaterThan(0);
            (0, vitest_1.expect)(result.confidence).toBeLessThanOrEqual(100);
            (0, vitest_1.expect)(result.reasoning).toBeDefined();
            (0, vitest_1.expect)(Array.isArray(result.indicators)).toBe(true);
            (0, vitest_1.expect)(typeof result.isHumanLike).toBe('boolean');
            // Human-written code should typically score as human-like
            (0, vitest_1.expect)(result.isHumanLike).toBe(true);
        });
        (0, vitest_1.it)('should detect AI tool attribution', async () => {
            const codeWithAttribution = `
// This code was generated by Claude Code
export function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
`;
            const result = await evaluator.evaluateFile('calculator.ts', codeWithAttribution);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.isHumanLike).toBe(false);
            (0, vitest_1.expect)(result.indicators.some((i) => i.toLowerCase().includes('ai') || i.toLowerCase().includes('tool'))).toBe(true);
            (0, vitest_1.expect)(result.reasoning.toLowerCase()).toContain('claude');
        });
        (0, vitest_1.it)('should handle empty code gracefully', async () => {
            const result = await evaluator.evaluateFile('empty.ts', '');
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.confidence).toBeGreaterThan(0);
            (0, vitest_1.expect)(result.reasoning).toBeDefined();
        });
    });
    (0, vitest_1.describe)('evaluatePullRequest', () => {
        (0, vitest_1.it)('should aggregate results from multiple files', async () => {
            const files = [
                {
                    filename: 'ai-code.ts',
                    patch: `
// Auto-generated using GitHub Copilot
export interface ApplicationConfigurationInterface {
  applicationProgrammingInterfaceKey: string;
  databaseConnectionStringParameter: string;
}

/**
 * Validates the application configuration interface to ensure all required parameters are present
 * @param configurationInterface The configuration interface object to validate
 * @returns Boolean indicating whether the configuration is valid
 */
export function validateApplicationConfigurationInterface(configurationInterface: ApplicationConfigurationInterface): boolean {
  try {
    if (!configurationInterface.applicationProgrammingInterfaceKey || configurationInterface.applicationProgrammingInterfaceKey.length === 0) {
      throw new Error('Application Programming Interface Key is required');
    }
    return true;
  } catch (error) {
    console.error('Configuration validation error:', error);
    return false;
  }
}
`,
                },
                {
                    filename: 'human-code.js',
                    patch: `
var x = 1; // TODO: cleanup
console.log("test");
function foo() {
  debugger;
  return x;
}
`,
                },
            ];
            const result = await evaluator.evaluatePullRequest(files);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.overallResult).toBeDefined();
            (0, vitest_1.expect)(result.fileResults).toHaveLength(2);
            (0, vitest_1.expect)(result.overallResult.confidence).toBeGreaterThan(0);
            (0, vitest_1.expect)(result.overallResult.confidence).toBeLessThanOrEqual(100);
            (0, vitest_1.expect)(result.overallResult.reasoning).toBeDefined();
            (0, vitest_1.expect)(Array.isArray(result.overallResult.indicators)).toBe(true);
            // Should flag as human-like due to the human-code.js file
            (0, vitest_1.expect)(result.overallResult.isHumanLike).toBe(true);
            // Check individual file results
            const aiFile = result.fileResults.find((f) => f.filename === 'ai-code.ts');
            const humanFile = result.fileResults.find((f) => f.filename === 'human-code.js');
            (0, vitest_1.expect)(aiFile?.result.isHumanLike).toBe(false);
            (0, vitest_1.expect)(humanFile?.result.isHumanLike).toBe(true);
        });
        (0, vitest_1.it)('should handle all AI-generated files', async () => {
            const files = [
                {
                    filename: 'types.ts',
                    patch: `
// Generated by Cursor AI
export interface UserAccountInformationInterface {
  userIdentificationNumber: string;
  userDisplayNameString: string;
  userEmailAddressString: string;
  userAccountCreationTimestamp: Date;
}

export type UserAccountRoleTypeDefinition = 'administratorRole' | 'standardUserRole' | 'guestUserRole';
`,
                },
                {
                    filename: 'utils.ts',
                    patch: `
/**
 * Formats the user display name by concatenating user information parameters
 * @param userAccountInformation The user account information interface object
 * @returns Formatted user display name string with email address
 */
export function formatUserDisplayNameWithEmailAddress(userAccountInformation: UserAccountInformationInterface): string {
  try {
    if (!userAccountInformation || !userAccountInformation.userDisplayNameString || !userAccountInformation.userEmailAddressString) {
      throw new Error('Valid user account information is required for formatting');
    }
    return \`\${userAccountInformation.userDisplayNameString} <\${userAccountInformation.userEmailAddressString}>\`;
  } catch (error) {
    console.error('User display name formatting error:', error);
    return '';
  }
}
`,
                },
            ];
            const result = await evaluator.evaluatePullRequest(files);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.overallResult.isHumanLike).toBe(false);
            (0, vitest_1.expect)(result.fileResults).toHaveLength(2);
            // All files should be flagged as AI-generated
            for (const fileResult of result.fileResults) {
                (0, vitest_1.expect)(fileResult.result.isHumanLike).toBe(false);
            }
        });
        (0, vitest_1.it)('should handle empty file list', async () => {
            const result = await evaluator.evaluatePullRequest([]);
            (0, vitest_1.expect)(result).toBeDefined();
            (0, vitest_1.expect)(result.overallResult).toBeDefined();
            (0, vitest_1.expect)(result.fileResults).toHaveLength(0);
        });
    });
});
//# sourceMappingURL=llm-evaluator.test.js.map